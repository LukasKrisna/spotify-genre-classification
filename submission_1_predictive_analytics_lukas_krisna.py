# -*- coding: utf-8 -*-
"""Submission_1_Predictive_Analytics_Lukas_Krisna (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X82ex8TMy4TzfaYQzGciKeJWEZo8VA2z

## Import Library
"""

!pip install tensorflow

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics
import tensorflow as tf
from tensorflow import keras
from sklearn.decomposition import PCA
import warnings
warnings.filterwarnings('ignore')

# Set random seeds for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

"""## Data Understanding & Data Preparation"""

data = pd.read_csv("genres_v2.csv")
data

data.info()

data.describe()

data.isnull().sum()

data.nunique()

columns_to_drop = ["type", "id", "uri", "track_href", "analysis_url",
                  "song_name", "Unnamed: 0", "title", "duration_ms", "time_signature"]
df = data.drop(columns_to_drop, axis=1)

"""Menghapus Kolom yang tidak relevan
langkah pertama dalam EDA pada proyek klasifikasi genre musik Spotify ini adalah menghapus kolom-kolom yang tidak diperlukan untuk proses pemodelan. Kolom-kolom ini mungkin tidak memberikan informasi yang relevan untuk membedakan genre musik atau bersifat redundant.
"""

df = df[df['genre'] != "Pop"].reset_index(drop=True)

"""Menghapus semua baris yang memiliki genre "Pop", kemudian mengatur ulang indeks DataFrame hasil filter tersebut agar berurutan kembali mulai dari 0.

Genre "Pop" dihapus untuk mengatasi masalah ketidakseimbangan kelas karena jumlahnya yang dominan, atau karena sifatnya yang terlalu luas sehingga dapat mengganggu model dalam mempelajari fitur pembeda genre lainnya yang lebih spesifik.
"""

genre_mapping = {
    "Trap Metal": "Rap",
    "Underground Rap": "Rap",
    "Emo": "Rap",
    "RnB": "Rap",
    "Hiphop": "Rap",
    "Dark Trap": "Rap"
}
df['genre'] = df['genre'].replace(genre_mapping)

"""Menyederhanakan atau mengelompokkan beberapa sub-genre spesifik (seperti "Trap Metal", "Underground Rap", "Emo", "RnB", "Hiphop", dan "Dark Trap") menjadi satu kategori genre yang lebih umum, yaitu "Rap"."""

print(df['genre'].value_counts())

rap_genre = df[df['genre'] == 'Rap'].sample(3000, random_state=42)
other_genre = df[df['genre'] != 'Rap']
df = pd.concat([rap_genre, other_genre]).reset_index(drop=True)

"""Kode tersebut melakukan downsampling pada genre "Rap" dengan mengambil sampel acak sebanyak 3000 lagu, kemudian menggabungkannya kembali dengan semua lagu dari genre lain untuk menyeimbangkan distribusi kelas"""

print(df['genre'].value_counts())

# Create new features
df['energy_danceability'] = df['energy'] * df['danceability']
df['acousticness_instrumentalness'] = df['acousticness'] * df['instrumentalness']
df['loudness_speechiness'] = df['loudness'] * df['speechiness']
df['tempo_energy'] = df['tempo'] * df['energy']

"""Melakukan feature engineering dengan menciptakan empat fitur baru dalam DataFrame df. Fitur-fitur baru ini (energy_danceability, acousticness_instrumentalness, loudness_speechiness, tempo_energy) merupakan hasil perkalian dari pasangan fitur yang sudah ada, yang berpotensi menangkap interaksi antar fitur tersebut untuk meningkatkan performa model."""

numerical_features = df.select_dtypes(include=[np.number]).columns
plt.figure(figsize=(20, 15))
for i, feature in enumerate(numerical_features, 1):
    plt.subplot(4, 4, i)
    sns.histplot(data=df, x=feature, kde=True)
    plt.title(f'Distribution of {feature}')
    plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""Visualisasi ini menampilkan histogram distribusi berbagai fitur audio dari dataset lagu Spotify. Banyak fitur seperti speechiness, acousticness, dan instrumentalness sangat condong ke kanan (right-skewed), menunjukkan mayoritas lagu memiliki nilai rendah pada fitur-fitur ini, sementara fitur seperti danceability, energy, dan loudness menunjukkan distribusi yang lebih simetris atau sedikit condong. Fitur-fitur baru yang diciptakan, seperti energy_danceability, umumnya mencerminkan karakteristik distribusi dari fitur-fitur asalnya."""

# Genre distribution
plt.figure(figsize=(12, 6))
sns.countplot(data=df, x='genre')
plt.xticks(rotation=45)
plt.title('Distribution of Genres')
plt.tight_layout()
plt.show()

"""Jumlah lagu untuk setiap genre (Rap, techhouse, techno, trance, psytrance, trap, dnb, hardstyle) kini relatif seimbang, masing-masing mendekati sekitar 3000 sampel. Keseimbangan ini penting untuk mencegah bias model terhadap genre tertentu selama pelatihan."""

# Box plots for key features by genre
key_features = ['danceability', 'energy', 'loudness', 'speechiness',
                'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo']

plt.figure(figsize=(20, 15))
for i, feature in enumerate(key_features, 1):
    plt.subplot(3, 3, i)
    sns.boxplot(data=df, x='genre', y=feature)
    plt.xticks(rotation=45)
    plt.title(f'{feature} by Genre')
plt.tight_layout()
plt.show()

"""Visualisasi ini menampilkan box plot yang membandingkan distribusi berbagai fitur audio (seperti danceability, energy, instrumentalness, speechiness, tempo) untuk setiap genre musik. Terlihat jelas bahwa beberapa fitur memiliki pola distribusi yang sangat berbeda antar genre, misalnya instrumentalness yang tinggi untuk genre elektronik seperti techno dan trance namun rendah untuk Rap, atau speechiness yang lebih tinggi pada genre Rap dan Trap

Mengingat data tersebut adalah fitur audio musik, outliers seringkali merepresentasikan variasi atau karakteristik unik yang valid dalam lagu atau genre tertentu, sehingga membersihkannya berpotensi menghilangkan informasi penting untuk klasifikasi.
"""

plt.figure(figsize=(15, 15))
sns.pairplot(df[['danceability', 'energy', 'loudness', 'speechiness', 'genre']],
             hue='genre', diag_kind='kde')
plt.show()

"""Visualisasi pair plot ini menampilkan bagaimana fitur-fitur kunci seperti danceability, energy, loudness, dan speechiness terdistribusi untuk setiap genre (pada panel diagonal) dan bagaimana mereka berinteraksi satu sama lain (pada panel scatter plot di luar diagonal), dengan setiap genre diwakili oleh warna yang berbeda. Sangat jelas terlihat bahwa speechiness menjadi pembeda kuat, dimana genre Rap dan Trap menunjukkan nilai yang jauh lebih tinggi dibandingkan genre lain, sementara genre elektronik seperti techno, trance, dan hardstyle cenderung berkelompok dengan nilai energy dan loudness yang tinggi, menunjukkan adanya pola yang dapat dieksploitasi untuk klasifikasi. Hubungan antar fitur lainnya juga memperlihatkan beberapa kecenderungan pengelompokan genre meskipun ada tumpang tindih, yang mengindikasikan pentingnya kombinasi fitur dalam membedakan genre musik."""

# Correlation heatmap
plt.figure(figsize=(15, 12))
correlation_matrix = df.select_dtypes(include=[np.number]).corr()
mask = np.triu(correlation_matrix)
sns.heatmap(correlation_matrix, mask=mask, annot=True, fmt='.2f', cmap='coolwarm',
            square=True, linewidths=.5)
plt.title('Feature Correlation Matrix')
plt.tight_layout()
plt.show()

"""Visualisasi ini adalah matriks korelasi fitur yang menunjukkan bagaimana setiap pasang fitur dalam dataset saling berhubungan secara linear, dengan warna merah mengindikasikan korelasi positif kuat dan biru untuk korelasi negatif kuat."""

# Correlation with target variable (using encoded genre)
plt.figure(figsize=(12, 6))
# Create a copy of numerical features
numerical_df = df.select_dtypes(include=[np.number]).copy()
# Add encoded genre
le = LabelEncoder()
numerical_df['genre_encoded'] = le.fit_transform(df['genre'])
correlations = numerical_df.corr()['genre_encoded'].sort_values(ascending=False)
correlations = correlations.drop('genre_encoded')  # Remove self-correlation
sns.barplot(x=correlations.index, y=correlations.values)
plt.xticks(rotation=45)
plt.title('Feature Correlation with Genre')
plt.tight_layout()
plt.show()

"""Berikut adalah diagram batang yang menampilkan koefisien korelasi antara setiap fitur audio dengan variabel target "genre" yang kemungkinan telah diubah menjadi representasi numerik. Fitur tempo menunjukkan korelasi negatif terkuat (sekitar -0.45), sementara energy menunjukkan korelasi positif terkuat (sekitar +0.28), diikuti oleh energy_danceability dan instrumentalness dengan korelasi positif yang juga cukup menonjol, serta acousticness dengan korelasi negatif yang signifikan. Hal ini mengindikasikan bahwa fitur-fitur dengan nilai korelasi (baik positif maupun negatif) yang lebih besar cenderung memiliki hubungan linear yang lebih kuat dengan urutan numerik genre tersebut, dan berpotensi menjadi prediktor yang lebih penting dalam model klasifikasi."""

X = df.drop('genre', axis=1)
y = df['genre']

"""Dataset dibagi menjadi dua bagian: fitur (variabel independen) yang disimpan dalam X dengan menghapus kolom 'genre', dan target (variabel dependen, yaitu 'genre' itu sendiri) yang disimpan dalam y"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""Fungsi train_test_split, data X dan y tersebut dibagi lagi menjadi data latih (X_train, y_train) dan data uji (X_test, y_test), dimana 20% dari total data dialokasikan untuk pengujian (test_size=0.2)"""

scaler = MinMaxScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""MinMaxScaler untuk menormalkan fitur pada data latih dan data uji, mengubah skala setiap fitur ke rentang antara 0 dan 1. Proses ini memastikan konsistensi perlakuan data dan mencegah kebocoran informasi dari data uji ke proses pelatihan model dengan hanya melakukan fit pada data latih"""

le = LabelEncoder()
y_train_encoded = le.fit_transform(y_train)
y_test_encoded = le.transform(y_test)

"""LabelEncoder untuk mengubah label genre tekstual pada data target menjadi representasi numerik

## Modeling

### Random Forest Model
"""

# Random Forest
rf_model = RandomForestClassifier(n_estimators=200, max_depth=20, random_state=42)
rf_model.fit(X_train_scaled, y_train_encoded)
rf_pred = rf_model.predict(X_test_scaled)

"""### Neural Network Model"""

early_stopping1 = keras.callbacks.EarlyStopping(
    monitor="val_loss",
    patience=15,
    restore_best_weights=True
)

early_stopping2 = keras.callbacks.EarlyStopping(
    monitor="val_accuracy",
    patience=15,
    restore_best_weights=True
)

model = keras.Sequential([
    keras.layers.Input(name="input", shape=(X_train_scaled.shape[1],)),

    keras.layers.Dense(512, activation="relu"),
    keras.layers.BatchNormalization(),
    keras.layers.Dropout(0.3),

    keras.layers.Dense(256, activation="relu"),
    keras.layers.BatchNormalization(),
    keras.layers.Dropout(0.3),

    keras.layers.Dense(128, activation="relu"),
    keras.layers.BatchNormalization(),
    keras.layers.Dropout(0.2),

    keras.layers.Dense(len(np.unique(y_train_encoded)), activation="softmax")
])

optimizer = keras.optimizers.Adam(learning_rate=0.0003)

model.compile(
    optimizer=optimizer,
    loss="sparse_categorical_crossentropy",
    metrics=["accuracy"]
)

model.summary()

history = model.fit(
    X_train_scaled, y_train_encoded,
    epochs=150,
    batch_size=64,
    validation_data=(X_test_scaled, y_test_encoded),
    callbacks=[early_stopping1, early_stopping2],
    verbose=1
)

"""## Evaluation"""

print("\nRandom Forest Results:")
print("Accuracy:", metrics.accuracy_score(y_test_encoded, rf_pred))
print("F1 Score:", metrics.f1_score(y_test_encoded, rf_pred, average='weighted'))
print("\nClassification Report:")
print(metrics.classification_report(y_test_encoded, rf_pred))

"""Hasil evaluasi model Random Forest menunjukkan secara keseluruhan, model mencapai akurasi sekitar 0.8949 dan F1-score sekitar 0.8947. Ini berarti model mampu mengklasifikasikan genre musik dengan benar pada sekitar 89.5% kasus dari data uji."""

# Neural Network Evaluation
nn_pred = model.predict(X_test_scaled).argmax(axis=1)
print("\nNeural Network Results:")
print("Accuracy:", metrics.accuracy_score(y_test_encoded, nn_pred))
print("F1 Score:", metrics.f1_score(y_test_encoded, nn_pred, average='weighted'))
print("\nClassification Report:")
print(metrics.classification_report(y_test_encoded, nn_pred))

"""Model neural network mencapai Akurasi sekitar 0.8814 dan F1 Score (rata-rata makro) sekitar 0.8810. Ini berarti sekitar 88.1% dari lagu dalam data uji berhasil diklasifikasikan dengan benar oleh model Neural Network."""

plt.figure(figsize=(15, 6))

plt.subplot(1, 2, 1)
sns.heatmap(metrics.confusion_matrix(y_test_encoded, rf_pred),
            annot=True, fmt='d', cmap='Blues')
plt.title('Random Forest\nConfusion Matrix')

plt.subplot(1, 2, 2)
sns.heatmap(metrics.confusion_matrix(y_test_encoded, nn_pred),
            annot=True, fmt='d', cmap='Blues')
plt.title('Neural Network\nConfusion Matrix')
plt.tight_layout()
plt.show()

"""Random Forest menunjukkan performa klasifikasi yang lebih baik daripada Neural Network. Hal ini terlihat dari nilai diagonal (prediksi benar) yang umumnya lebih tinggi pada Random Forest, terutama untuk kelas 1, 2, 3, 4, dan 6. Random Forest juga menunjukkan lebih sedikit kesalahan klasifikasi antar kelas dibandingkan Neural Network.

Neural Network cenderung menghasilkan lebih banyak misklasifikasi, terutama terlihat pada kelas 2, 3, 5, 6, dan 7 yang memiliki beberapa prediksi salah tersebar ke kelas lain. Namun, Neural Network menunjukkan performa yang cukup baik untuk kelas 1 dan 4.
"""

plt.figure(figsize=(15, 5))

plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.tight_layout()
plt.show()

print("\nModel Comparison Summary:")
models = {
    'Random Forest': rf_pred,
    'Neural Network': nn_pred
}

comparison_df = pd.DataFrame({
    'Model': list(models.keys()),
    'Accuracy': [metrics.accuracy_score(y_test_encoded, pred) for pred in models.values()],
    'F1 Score': [metrics.f1_score(y_test_encoded, pred, average='weighted') for pred in models.values()]
})

print("\n", comparison_df.to_string(index=False))

"""Secara keseluruhan, Random Forest sedikit lebih akurat dan konsisten dalam mengklasifikasikan semua kelas dibandingkan Neural Network untuk dataset ini."""

